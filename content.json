{"pages":[],"posts":[{"title":"java-core","text":"简单性 面向对象 网络技能 健壮性 安全性 体系结构中立 可移植性 解释型 高性能 多线程 动态性 基本结构12345public class Base64Test { public static void main(String[] args) { System.out.println(&quot;hello world!&quot;); }} public：访问修饰符 class：关键字，后紧跟类名 main：程序入口 注释12345//这是个注释/* * 这也是个注释*/ 数据类型整数 类型 存储需求 取值范围 表示 int 4 Byte -2^32 ~ 2^32 - 1 100 short 2 Byte -2^16 ~ 2^16 - 1 100 long 8 Byte -2^64 ~ 2^64 - 1 100L byte 1 Byte -2^8 ~ 2^8 - 1 (-128 ~ 127) 100 十六进制：前缀0x，0x100 八进制：前缀0（如：0100），容易混淆，少用 二进制：前缀0b 浮点数 类型 存储需求 取值范围 表示 float 4 Byte 有效位数6~7位 100.123F double 8 Byte 有效位数15位 100.123D 特殊值： 正无穷大：POSITIVE_INFINITY 负无穷大：NEGATIVE_INFINITY 不是一个数：NaNm，用法 Double.isNaN(var) 浮点数计算会有误差，要准确计算需使用BigDecimal类 char 定义：用于表示单个字符，即1个unicode代码单元（取值范围，unicode第一平面的索引：0-65535） 长度：2 Byte 代码点：一个编码表中的某个字符对应的代码 代码单元：组成字符的具体字节称为代码单元 unocide编码：多语言编码，可以分为17个代码级别 基本的多语言级别：U+0000-U+FFFF 附加级别：U+10000-U+10FFFF utf-16保留区域 UTF-16的高半区：U+D800-U+DBFF UTF-16的低半区：U+DC00-U+DFFF utf-16编码：变长，2/4字节 基本的多语言级别：1个代码单元16位（2 Byte），即1个char 附加级别：2个代码单元32位（4 Byte），即2个char 级别区分：附加级别的单个代码单元范围会在utf-16保留区域内，即读一个单元，在保留区域就是附加级别，需读第二个单元 第一个代码单元：U+D800-U+DBFF 第二个代码单元：U+DC00-U+DFFF bool 值：true/false 整形值和boolean之前不能互相转换 变量 变量名：字母开头，由字母和数字构成的序列 大小写敏感，长度不限制 字母范围包括A-Z，a-z，’_’，$或在某种语言种代表字母的unicode字符 数字0-9，某种语言中代表数字的unicode字符 使用方法isJavaIdentifierStart和isJavaIdentifierPart判断是否可以 变量初始化 全局变量自动初始化 局部变量使用前需初始化 常量： final + static修饰的变量 只能被赋值一次，一旦赋值就不能更改 习惯上常量名使用全大写 运算符算术运算符 + - * / 自增、自减 i++ ++i i– –i 关系运算 == != “&gt;” &lt; “&gt;=” &lt;= 布尔运算 与 &amp;&amp; 或 || 非 ! 三目运算符 ?:1ex1 ? ex2 : ex3 位运算 与 &amp; 或 | 异或 ^ 非 ~ 右移 “&gt;&gt;” 左移 &lt;&lt; 用0填充高位 “&gt;&gt;&gt;” 数学运算与常量Math类提供了各种各样的数学函数 平方根sqrt 绝对值abs 三角函数 sin cos tan atan atan2 指数函数及其反函数 exp log log10 派的近似值PI e常量的近似值E 类型转换 整形转换：byte-&gt;short-&gt;int-&gt;long，数据长度增加，不损失精度 浮点转换：float-&gt;double，数据长度增加，不损失精度 整形转浮点 int -&gt; double，数据长度增加，不损失精度 int -&gt; float，long -&gt; double数据长度减少，可能损失精度 char-&gt;int：char转int，char指向的内存中的二进制内容，只是对它的使用改变了 int的值是char的ascii码 获取char表示的数值：Character.getNumericValue(c)或Integer.parseInt(String.valueOf(c)); 不同类型的计算，默认会将长度小的类型升格为大的类型，在进行计算如：long + int -&gt; long 强制转换 本质上是读取的内存中的数据缩小了，变量类型变了，对应的数据范围变了，实际数据未改变 如(byte)300-&gt;44，读1个字节（从低到高读），300（1 0010 1100），44（0010 1100） 如double x=9.997, int nx = (int) x，nx的值为9，只读取了低4byte数据 括号与算术符优先级 枚举类型定义：变量的取值只在一个有限的集合内 1enum Size {SMALL, MEDIUM, LARGE. EXTRA_LARGE} 字符串 定义：字符串就是unicode字符序列 内部存储为byte数组，所有的操作按char进行 java没有内置字符串类型，而是提供的java.lang.String类 子串1234substring(0, 3);//[0,3)//0,1,2,不包括3//长度3-0=3 拼接 使用“+”连接两个字符串 一个字符串与一个非字符串的值进行拼接，后者被转换为字符串 不可变字符串 string对象的内容都是不可变的 编译器让字符串以对象池方式进行共享，以提高性能 只有常量字符串是在对象池中共享的，即加了final的字符串 检测是否相等12// 不能使用”==“进行判断”==“对于对象，判断的是地址是否相同，多个相同的字符串，其地址可能不同s.equals(t) 空串与null串 空串：“” 12345// 字符长度0str.length() == 0// 内容为空&quot;&quot;.equals(str) null：表示该变量没有与任何对象关联 1str == null 代码点和代码单元12345678910// 返回index处unicode代码点索引，如 𝕫 的unicode编码：U+1D56B（十六进制），十进制：120171// 代码点转char：Character.toChars得到char数组 ，如 Character.toChars(0x1D56B) = [D835, DD6B]int codePointAt(int index)// 返回startIndex到endIndex-1之间的代码点数量，没有配成对的代码字符将计入代码点// 例：int count = str.codePointCount(0,str.length())- int codePointCount(int startIndex, int endIndex)// 返回从startIndex代码点开始，位移cpCount后的代码点索引- int offsetByCodePoionts(int startIndex, int cpCount) 常用函数1234567891011121314151617181920212223242526272829303132333435363738//返回字符的长度（按char计）（byte数组长度/2）int length()//返回index的char值(0 &lt; index &lt; s.length - 1)int charAt(int index)//比较两个字符串中每个char值，返回长度差/char相减差int compareTo(String other)//如果字符串以suffix结尾，返回trueboolean endsWith(String suffix)//如果字符串与other相等，返回trueboolean equals(Object other) //如果字符串与other相等，返回trueboolean equalsIgnoeCase(Object other)//返回与字符串str或代码点cp匹配的第一个字串的开始位置boolean indexOf(String str/int cp)//返回与字符串str或代码点cp匹配的最后一个字串的开始位置int lastIndexOf(String str/int cp)//使用newString替换oldString，可以用String/StringBuilder作为参数String replace(CharSequence oldString, CharSequence newString)//返回截取beginIndex到endIndex-1的字符串String substring(int beginIndex, int endIndex)//字符串所有大写字母改小写String toLowerCase()//字符串所有小写字母改大写String toUpperCase()//删除字符串前后空格String trim() 构建字符串1234567891011121314151617181920212223242526272829// 内部使用byte数组存储，方法的操作单位都是char，StringBuffer线程安全，一般使用StringBuilderAbstractStringBuilder// 数组中char的数量int length()// 追加一个字符串，并返回thisStringBuilder append(String str)// 追加一个代码单元并返回thisStringBuiler append(char ch)// 追加一个代码点并返回thisStringBuiler appendCodePoint(int cp)// 将第i个char设置为cvoid setCharAt(int i, char c)// 在offset位置插入一个字符串并返回thisStringBuilder insert(int offset, String str)// 在offset位置插入一个char并返回thisStringBuilder insert(int offset, char ch)// 删除startIndex~endInde-1的char并返回thisStringBuilder delete(int startIndex, int endIndex)// 返回一个与构建器内容相同的字符串String toString() 输入输出控制台输入（Scanner）123456789101112131415161718192021// 用给定的输入流创建一个Scanne对象// System.in：标准输入// System.out：标准输出Scanner (InputStream in)// 读取输入的下一行内容String nextLine()// 读取输入的下一个单词（空格作为分隔符）String next()// 读取并转换下一个表示整数/浮点数的字符序列int nextInt()double nextDouble()// 检测输入中是否还有其他单词boolean hasNext()// 否还有表示整数/浮点数的下一个字符序列boolean hasNextInt()boolean hasNextDouble() 格式化输出 遵循c的printf规范 占位符：% 参数索引：%X$，如%2$，表示第二个传入的参数 将被格式化的数值类型 输出各种标志 日期和时间转换符 格式说明 文件输入和输出 输入：Scanner in = new Scanner(Paths.get(“file.txt”)); 输出：PrintWriter out = new PrintWriter(“file.txt”); 控制流程块作用域 块：复合语句块 由一对 “{ }” 括起来的若干条java语句 块确定了变量的作用域 允许嵌套，一个块可以嵌套在另一个块之中 1234567891011121314151617181920public static void main(String[] args){ int n; ... { int k; ... } // k is only defined up to here}// n is only defined up to herepublic static void main(String[] args){ int n; ... { int k; int n; //ERROR 不能在嵌套的两个块中声明同名的变量 ... }} 条件语句1234567891011121314151617181920if (condition) statement//使用块语句，执行多条语句if (contidion) { statement1; statement2; statement3;}//分支if (condition) statement1else statement2//多分支if (condition1) statement1else if(condition2) statement2else if(condition3) statement3else statement4 if语句流程图 if/else流程图 if/else if(多分支)流程图 循环 常用流程12345678while (condition) statement//执行多条语句while (condition) { statement1; statement2; statement3;} do-while12345678do statement while (condition)//执行多条语句do { statement1; statement2; statement3;} while (condition) 确定循环12345for (int i = 0; i &lt; 10; i++){ statement1; statement2; statement3;} 多重选择switch12345678910111213switch (choice){ case &quot;case1&quot;: ... break; case &quot;case2&quot;: ... break; case &quot;case3&quot;: ... break; default: ...} 如果没有break，会继续执行下一个case分支 case的标签 是char，byte，short，int 枚举常量，不必显示指出枚举类名，由表达式自动推导 String（java se 7+） 循环控制 中断循环break 1234567while (condition) { ... ... if(xxx) break; ... ...} 跳过此次循环continue 1234567while (condition) { ... ... if(xxx) continue; ... ...} 大数值BigInteger：任意精度整数运算1234567static BigInteger valueOf(long val)BigInteger add(BigInteger val) //加BigInteger subtract(BigInteger val) //减BigInteger multiply(BigInteger val) //乘BigInteger divide(BigInteger val) //除BigInteger mod(BigInteger m) //取余int compareTo(BigInteger val) //比较大小 BigDemical：任意精度浮点数运算123456static BigDecimal valueOf(double val)BigDecimal add(BigDecimal augend) //加BigDecimal subtract(BigDecimal subtrahend)//减BigDecimal multiply(BigDecimal multiplicand)//乘BigDecimal divide(BigDecimal divisor)//除int compareTo(BigDecimal val)//比较大小 数组声明使用new创建数组，指出数组类型，数组变量的名字： 1int[] a = new int[100]; 默认值：数字数组初始化为0，boolean数组初始化为false，对象数组初始化为null 数组一旦创建就不能改变大小 a.length获取长度 for each循环只能遍历一维数组 collection可以是数组或实现了Iterable接口的对象 12345// 定义一个变量variable用于暂存collection中的元素，并执行相应的语句（块）statement for (variable : collection) statement;// 快速打印数组元素String str = Arrays.toString(collection); 数组初始化及匿名数组 初始化int[] a = new int[] {1, 2, 3, 4, 5, 6}; 简化int[] a = {1, 2, 3, 4, 5, 6}; 匿名new int[] {1, 2, 3, 4, 5, 6}; 数组拷贝 地址传递1int[] a = b 内容拷贝123456int[] b = Arrays.copyOf(a, a.lenth);//扩张，多余的元素会被初始化为0/false/nullint[] b = Arrays.copyOf(a, a.lenth * 2);//裁剪，只拷贝最前面的元素int[] b = Arrays.copyOf(a, 3); 对于对象数组，拷贝的是对象的引用，即浅拷贝 命令行参数1234java Message -g curel worldarg[0] = &quot;-g&quot;;arg[1] = “curle”;arg[2] = &quot;world&quot;; Arrays函数123456789101112131415161718192021222324252627// 返回包含a中元素的字符串static String toString(type[] a)// 返回与original类型相同的数组，长度为newLength- static type[] copyOf(type[] original, int newLength)// 返回与original类型相同的数组，长度为to-from- static type[] copyOfRange(type[] original, int from, int to)// 采用优化的快速排序算法对数组进行排序static void sort(type[] a)// 将数组a的所有元素设置为val static void fill(type[] a, type val)/* * 采用二分查找法，查找key，找到则返回相应的下标，否则返回负数值r，-r-1是为保持a有序key应插入的位置 * a：有序数组，类型为数字 * fromIndex：起始下标，包含这个值 * toIndex：终止下标，不好含这个值 * key：同a元素数据类型相同的值*/static int binarySearch(type[] a, type key)static int binarySearch(type[] a, int fromIndex, int toIndex, type key)// 如果两个数组大小相同且下标元素相同，则返回truestatic type equals(type[] a, type[] a2) 多维数组与不规则数组 声明12//数组的内容是数组int[][] a = {{1,2,3}, {1,2,3}, {1,2,3}}; 不规则数组12//即数中的数组长度不一致int[][] a = {{1,2,3}, {1,2}, {1,2,3,4}}; 对象与类概述 类：将数据与行为组合在一个包中 状态 方法 对象：类的实例，通过对象标识区别不同对象 类名：类名为名词，方法为动词 类之间的关系 依赖：use-a 聚合：has-a 继承：is-a 类使用 构造对象：ClassXXX xxx = new ClassXXX(var1, var2, var3); xxx为对象的引用，即对象地址 调用方法：xxx.functionXXX(var1, var2, var3); 通过使用方法而不是直接调用类变量，可以有效控制数据的访问，为后续的扩展提供便利 访问变量：xxx.var1; 类组成 变量 方法 构造器操作符：new引用类中其他构造器：使用“this” 普通方法：操作符：“.”引用类中其他方法：使用方法名 参数元类型：传值，拷贝值引用类型：传址，拷贝地址，内部函数对地址的修改不影响外部变量 重载定义：方法有相同的名字，但是参数不同重载解析：编译器通过对参数类型的匹配来确定指向哪个方法 修饰符 访问控制 public：公共访问权限 private： 私有访问权限 protected：继承访问权限，同包下也可访问 default：包访问权限, 无关键字 一个方法可以访问所属类的所有对象的私有数据 控制符之间互斥，一次只能有一个控制符 final：变量修饰符 构建对象时必须对final变量进行初始化 初始化后不能在变更（即那一块内存区域内容固定） 元数据：内容不能在变更 对象变量：指向的对象不能在修改 static 用途：修饰变量，方法，语句块，被修饰的部分，归属于类而不是对象，即所有对象共享同一份static变量、方法 静态常量1public static final double PI = 3.14159265358979323846 静态方法12345678// 静态方法只能访问静态变量public static int getNextldO(){ return nextld ; // returns static field}// 通过类名访问int n = Employee.getNextldO(); 工厂方法：静态方法的常见用途 无法命名构造器构造器的名字必须与类名相同。这里希望将得到的货币实例和百分比实例采用不用的名字。 构造不同类型的对象当使用构造器时，无法改变所构造的对象类型。而Factory方法将返回一个DecimalFormat类对象 main方法程序入口，main方法不对任何对象进行操作。事实上，在启动程序时还没有任何一个对象。静态的main方法将执行并创建程序所需要的对象 对象构造 无参构造函数仅当类没有提供任何构造器的时候 ，系统才会提供一个无参的构造器 域初始化 默认初始化如果没有显示的赋值，则自动赋予默认值，数值为0，bool为false，对象引用为null 显示初始化 域定义时就进行赋值 通过构造器赋值 初始化块：调用构造器时就会被执行123456789101112{ ...; ...; ...;}// 静态初始化块，只会被执行一次static { ...; ...; ...;} 初始化顺序 所有数据域被初始化为默认值（0，false，null） 类第一次初始化，按照在类中声明的次序执行静态域初始化语句及静态初始化块 按照在类中声明的次序，依次执行实例域初始化语句及实例初始化块 如果构造器第一行调用了第二个构造器，则执行第二个构造器主体 执行这个构造器的主体 即：域默认值 &gt; 静态域、静态块 &gt; 实例域、实例块 &gt; 构造器 对象析构：finalize方法可以为类添加finalize方法，finalize方法将在垃圾回收器清除对象之前调用 包 包名如：package com.study.java; 类的包名要与类路径匹配，com.study.java对应com/study/java/ 类的导入 默认，全路径方式 1java.time.LocalDate today = java.time.LocalDate.now (); 导入：使用import 12import java.time.LocalDate;LocalDate today =LocalDate.now (); 静态导入：import static 可以用“*”导入包中的所有类，一个import仅允许导入一个包 类路径 类路径：包含所有类文件路径的集合，是搜寻类的起始点 当前目录：”.” class基目录：/home/user/classdir jar文件：archiver.jar 设置类路径1java -classpath /home/user/classdir:.:/home/user/archives/archiver.jar 文档注释 类注释对类进行描述1234/** xxxxx* xxxxx*/ 方法注释 @param：参数描述，一个方法的所有参数描述必须放在一起 @return：返回值描述 @throws：异常描述12345/** @param xxxxxx* @return xxxxxxx* @throws xxxxxx*/ 域注释123456/** * The scale of this BigDecimal, as returned by {@link #scale}. * * @serial * @see #scale */ 通用注释 @auther：作者 @version：版本 @since：始于 @deprecated：不推荐 @see：引用，可以加超链接 包与概述注释 注释的抽取 继承（类的扩展）类、超类、子类语法 定义 extends：使用extends表明新类派生于一个已存在的类 super：子类调用超类内容使用super关键字 12345678910111213public class Manager extends Employee{ ..... public Manager() { super(...); } ... public void xxx(){ super.xxx(...); }} 已存在的类称为超类，新类称为子类，因此子类拥有比超类更多的数据和功能 面向对象设计中，习惯性将通用方法放在超类，特殊方法放到子类 覆盖方法 java允许子类提供一个新的方法来覆盖超类中的 允许子类将返回类型修改位原返回类型的子类 方法可见性不能低于超类 123456789101112public class Manager extends Employee{ ... @override public double getSlary() { ... } ...} 子类构造器 子类的构造器必须调用超类构造器，且必须在第一条语句 如果没有显示调用，则默认调用无参构造器 12345public Manager (String name, double salary, int year, int month, int day){ super (name, salary, year, month, day ) ; bonus = 0 ;} 阻止继承 关键字：final 功能：用于阻止该类/方法的扩展，如String 123456789101112131415// 在类上public final class Executive extends Manager{ ...}// 方法public class Employee{ ... public final String getName(){ return name; } ...} 抽象类 关键字：abstract，用于表示基类，而不是特定的实例类 功能：可以定义抽象方法，还可以包含具体的数据与方法，介于接口与实例类之间的一种类 不包含抽象方法也可声明为抽象类 抽象类不能实例化，只能引用非抽象的子类对象 123456789101112131415public abstract class Person { private String name ; public Person(String name) { this.name = name; } public abstract String getDescription(); public String getName() { return name; }} 使用 多态 定义：一个对象变量可以指示多种实际类型的现象称为多态 1234567Employee e ;e = new Employee (...) ; // Employee object expectede = new Manager (...) ; // OK, Manager can be used as wellManager[] managers = new Manager[10];Employee[] staff = managers; //合法staff[0] = new Employee(); //非法，会抛出ArrayStoreException 数组会记录创建时的元素类型，仅将类型兼容的引用存储到数组中 方法调用过程 查看对象的类型和方法名 确定入参类型 通过入参类型确定方法 如果存在一个与所提供参数完全匹配的方法，就选择这个方法（这个过程称为重载解析） 如果未找到与参数类型匹配的方法或者经过类型转换后有多个方法与之匹配，编译器会报告错误 确定方法 静态绑定：具有唯一性，可以直接确定具体方法（private、static、final、构造器） 动态绑定：存在多个相同的方法签名，要通过方法表来确定x所引用对象的实际类型对应的方法 方法寻找的过程中，因为存在继承关系，在子类中不存在该方法时，要去其父类中寻找，每次调用都去搜索开销大 编译器生成方法表，列出所有方法的签名（方法的名字和参数列表称为方法的签名）和要调用的实际方法，虚拟机根据放发表进行调用 123456789101112Employee： getName() -&gt; Employee.getName(); getSalary() -&gt; Employee.getSalary(); getHireDay() -&gt; Employee.getHireDay(); raiseSalary(double) -&gt; Employee.raiseSalary(double);Manager: getName() -&gt; Employee.getName(); getSalary() -&gt; Manager.getSalary(); getHireDay() -&gt; Employee.getHireDay(); raiseSalary(double) -&gt; Employee.raiseSalary(double); setBouns(double) -&gt; Manager.setBouns(double) 目的：实现无需对现有代码进行修改就可以对程序进行扩展 对象类型转换 目的：使用对象的全部功能 在Java中，每个对象变量都属于一个类型。类型描述了这个变量所引用的以及能够引用的对象类型。 java是强类型语言，对象的转换与存储都会执行类型检查，异常时抛出ClassCastException 转换之前进行类型判断，可以避免抛出ClassCastException异常 12345if (staff[1] instanceof Manager){ boss = (Manager) staff[1]; ...} Object：所有类的超类 Object是所有类的始祖类，默认自动继承，不需要显示声明java中除了基本类型外都继承object（包括基本类型数组） equals：用于检测一个对象是否等于另外一个对象 引用相同（object默认） 字段相等（lombok重写），如数据库层DTO类 hashCode Object的默认hash由存储地址得出 String的hash由内容得出equals相等，hashCode也要相等 toString object默认会打印类名+散列码 字符串+对象：自动调用对象的toString方法进行拼接 相等测试与继承 原则 自反性 1x.equals(x) = true 对称性 12x.equals(y) = true;y.equals(x) = true; 传递性 1234x, y, z;x.quals(y) = true;y.equals(z) = true;z.equals(x) = true; 一致性 123456// x，y对象无变化x.equals(y) // true 返回值不变x.equals(y) // true 返回值不变x.equals(y) // true 返回值不变x.equals(y) // true 返回值不变x.equals(y) // true 返回值不变 null 1x.equals(null) = false 继承与相等性：java类库中各有各的逻辑，没有统一标准 由子类决定相等性，则对称性需要强制使用getClass检测 由超类决定相等性，使用instanceOf检测，这样可以比较不同的子类对象 equals编写建议 显示参数命名为otherObject 比较引用 12if (this == otherObject) return true;if(otherObject == null) return false; 比较类型，视详情使用instanceOf/getClass 12if(getClass() != otherObject.getClass()) return false;if(!(otherObject instanceOf ClassName)) return false; 比较字段 1234567// 基本类型用 ==3 == 5 // 对象用equalsEmployee e1,e2;...e1.equals(e2); 对象包装器与自动装箱、拆箱实际是编译器生成的语法糖 包装器：将基本类型包装成对象的类（Integer、Long、Float、Double、Short、Byte、Character、Boolean） 包装器是不可变对象 包装器是final的，不允许继承 装箱：int -&gt; Integer，由编译器自动完成而不是虚拟机 拆箱：Integer -&gt; int，由编译器自动完成而不是虚拟机 比较 “==”基本类型比值，包装器比较的是对象的引用（编译器默认比较规则） boolean、byte、char&lt;=127、介于-128和127之间的short和int被包装到固定对象中（对象池），此时==两边的对象是同一个 使用 1234567Integer n = 1;n++; // 拆箱，自增计算，装箱Double x = 2.0;Double y = n + x //Integer拆箱，提升为dobuel，Double拆箱，进行计算，结果装箱为Doubleboolean result = true ? n : x; //Integer拆箱，提升为dobuel在装箱为Double 常用方法 1234567891011121314151617181920// 返回对象的int值int intValue()// 返回对象的十进制字符串static String toString(int i)// 返回对象的指定进制的字符串static String toString(int i, int radix)// 返回字符串表示的整数，s必须是十进制static int parseInt(String s)// 返回字符串表示的整数，按radix进行进制解析static int parseInt(String s, int radix)// 返回字符串表示的Integer，s必须是十进制static Integer valueOf(String s)// 返回字符串表示的Integer，按radix进行进制解析static Integer valueOf(String s, int radix) 参数变量可变的方法实际是编译器生成的语法糖 语法 123public PrintStream printf(String fmt, Object... args) { ...} 编译器会将args参数绑定到数组中，”Object…”类型等同于”Object[]” args中还可以包含数组参数 枚举类 枚举类的构造器是私有的 所有的枚举类都是java.lang.Enum类的子类 123456789101112131415161718public enum Size { SMALL, MEDIUM, LARGE, EXTRA_LARGE }Size[] values = Size.values;// java.lang.Enum 方法// 返回给定类型中有指定名字的枚举常量static Enum valueOf(Class enumType, String name)// 如：Size s = Enum.valueOf(Size.class, &quot;SMALL&quot;); // 返回枚举常量名String toString()// 返回枚举常量在enum声明中的位置，从0开始int ordinal() // 比较两个枚举的位置，this==other返回0，this在other之前返回负整数，this在other之后返回正整数int compareTo(E o) 反射Java 运行时系统始终为所有的对象维护一个被称为运行时的类型标识 。这个信息跟踪着每个对象所属的类 。 虚拟机利用运行时类型信息选择相应的方法执行。反射库可以对类型信息进行读取和操作。 运行时分析类的能力 运行时查看对象 实现通用的数组操作代码 利用Method动态调用对象的方法 Class定义：保存运行时对象类型信息的类 如：Employee.class，int.class 1234567891011121314151617181920212223// Object.getClass()Employee e = new Employee();Class cl = e.getClass();// Class.forName()String className = &quot;java.util.Random&quot;;Class cl = Class.forName(className);// XX.classClass cl1 = Random.class;Class cl2 = int.class;Class cl3 = Double[].class;// 获取类名String getName()// String.class.getName() returns &quot;java.lang.String&quot;// Double[].class.getName() returns &quot;[Ljava.lang.Double;&quot;// int[].class.getName() returns &quot;[I&quot; // 比较Class cl1 = new Employee().getClass();Class cl2 = new Employee().getClass();cla == cl2 // true，同一个类的对象，class是同一个 分析类的能力 Field：域 Method：方法 Constructor：构造器 1234567891011java.lang.Class// 返回类提供的public域，方法，构造器，包括超类的成员Field[] getFields();Method[] getMethods()Constructor&lt;?&gt;[] getConstructors()// 返回类中声明的全部域，方法，构造器，包括私有和受保护成员，但不包括超类Field[] getDeclaredFields()Method[] getDeclaredMethods()Constructor&lt;?&gt;[] getDeclaredConstructors() 123456789101112131415161718192021222324java.lang.reflect.Fieldjava.lang.reflect.Methodjava.lang.reflect.Constructor// 返回该域/方法/构造器由哪个class定义Class&lt;?&gt; getDeclaringClass()// 返回变量/方法/构造器名称String getName()// 返回修饰符的整形数值int getModifiers()// Constructor、Method// 返回方法抛出的异常类型的Class对象数组Class&lt;?&gt;[] getExceptionTypes()// Constructor、Method// 返回一个用于描述参数类型的Class对象数组Class&lt;?&gt;[] getParameterTypes()// Constructor、Method// 返回一个用于描述返回类型的Class对象Class&lt;?&gt; getReturnType() 1234567891011121314java.lang.reflect.Modifierstatic String toString(int mod)static boolean isAbstract(int mod)static boolean isFinal(int mod)static boolean isInterface(int mod)static boolean isNative(int mod)static boolean isPublic(int mod)static boolean isPrivate(int mod)static boolean isProtected(int mod)static boolean isStatic(int mod)static boolean isStrict(int mod)static boolean isSynchronized(int mod)static boolean isVolatile(int mod) 分析对象 反射机制受限于java的访问控制 如果一个java程序没有受到安全管理器的控制，就可以覆盖访问控制 12345678910java.lang.reflect.AccessibleObject// 设置可访问标志，flag为true表明屏蔽java语言的访问检查，使得私有属性也可以被查询和设置void setAccessible(boolean flag)// 返回对象的可访问标志的值boolean canAccess(Object obj)// 设置一组对象的可访问标志static void setAccessible(AccessibleObject[] array, boolean flag) 1234567java.lang.Field// 返回obj中用Filed对象表示的域值Object get(Object obj)// obj对象中Field对象标识表示的域设置新值void set(Object obj, Object value) 数组操作12345678910111213141516java.lang.reflect.Array// 获取数组元素static Object get(Object array, int index)static xxx getXxx(Object array, int index)// 设定数组元素static void set(Object array, int index, Object value)static void setXxx(Object array, int index, Object value)// 获取数组长度static native int getLength(Object array)// 创建一个新数组static Object newInstance(Class&lt;?&gt; componentType, int length)static Object newInstance(Class&lt;?&gt; componentType, int... dimensions) 方法调用1234567java.lang.reflect.Method/* * obj：对象 * args：参数 */Object invoke(Object obj, Object... args) 接口接口不是类，而是对希望符合这个接口的类的一组需求。 java是强类型语言，名字相同但未实现接口，则不能进行转换，即类型不同。 语法定义接口中的方法总是public的 12345// 定义class Employee implements Compareable // 使用Double.compare(e1,e2); 接口的属性接口中的字段总是public static final 123public interface Powered extends Moveable { double SPEED_LIMIT = 95;} 接口与抽象类每个类只能扩展一个类，却能实现多个接口 抽象类是一个类，类是对象的具体描述，其属性可以有不同的实例。 接口是行为规范，定义类的行为，接口的属性是单例的。 静态和私有方法从java8开始允许在接口中增加静态方法。 之前，通常是建立一个伴随类，将静态方法放在伴随类中，如Path/Paths，Collection/Collections 1234public interface Path { public static Path of(URI uri) {...} public static Path of(String first, String... more) {...}} 默认方法接口可以定义默认的实现，关键字default 默认方法一般用于“接口演化”，对接口增加新的定义后，不必对旧有实现进行修改。 123456public interface Comparable&lt;T&gt;{ default int compareTo(T other){ return 0; }} 默认方法冲突如果两个接口存在同名的方法， 且都定义了默认方法，会造成二义性。 处理：实现类必须显示覆盖来解决冲突，即由实现类处理。 1234567891011121314interface Person { default String getName() {...}}interface Named { default String getName() {...}}class Student implements Person, Nmaed{ public String getName(){ // 可以使用其中一个默认实现 return Person.super.getNmae(); } } 使用接口与回调回调：一种设计模式，可以指定在特定事情发生时应该采取的动作。 12345678910111213public interface ActionListener { void actionPerformed(ActionEvent event);}class TimerPrinter implements ActionListener { void actionPerformed(ActionEvent event){ ... }}var listener = new TimePrinter();Timer t = new Timer(1000, listener);t.start(); Comparator接口12345678910111213public interface Comparator&lt;T&gt; { int compare(T o1, T o2);}class LengthComparator implements Comparator&lt;String&gt; { public int compare(String o1, String o2){ ... }}var cmp = new LengthComparator();if(cmp.compare(words[i],words[jk]) &gt; 0) ...Arrays.sort(array, cmp); 对象克隆 拷贝与克隆的区别： Copy是复制对象的引用，指向的对象是同一个。 Clone是复制整个对象的值，指向的对象不同。 Clone：Object默认实现，浅拷贝。内部对象只复制引用。 Deep Clone：需要具体类自己做，内部对象都要复制一份。 使用 clone是object的protect方法，子类需要重新定义一个public方法 12345678910111213class Employee implements Cloneable { // 重写，将protected修改为public，继承可以扩张修饰符的范围，接口方法的范围不能扩张(没有比public更大了) // 如果这个对象没有实现Cloneable接口，Object的clone方法会抛出CloneNotSupportedException异常 public Employee clone() throws CloneNotSupportedException { //deep clone Employee cloned = super.clone(); cloned.hireDay = (Date)hireDay.clone(); return cloned; }}var original = new Employee(&quot;Jone Public&quot;， 50000);var copy = original.clone(); lambda表达式lambda表达式是一个可传递的代码块，可以在以后执行一次或多次。 实际是编译器的生成的语法糖。 语法1234567891011121314(Type param) -&gt; statement/{...}(String first, String second) -&gt; { ...}// 可以没有参数() -&gt; {...}// 如果可以推导出类型，则可以省略类型(first, second) -&gt; {...}// 如果只有一个参数，且可以推导出类型，则可以省略括号first -&gt; {...} 函数式接口只有一个抽象方法的接口，需要这种接口的对象时，就可以提供一个lambda表达式。 lambda表达式本质上是个语法糖，编译器将lambda表达式转换为函数式接口的实现类。 12// 以Comparable接口为例，更多接口在java.util.function包中Arrays.sort(words, (fitrst, second) -&gt; first.length() - second.length()); 方法引用当lambda表达式的内容只有一个方法调用时，可以再次进行缩写; 123var Timer = new Timer(1000, event -&gt; System.out.println(event));var timer = new Timer(1000, System.out::println); 例子 object::instanceMethod Class::instanceMethod Class::staticMethod 1234567891011// object::instanceMethod，即object.instanceMethod(param...)separator::equals, x-&gt; separator.equals(x); // Class::instanceMethod，即param1.instanceMethod(param2，param3...)// 第一个参数会成为方法的隐式参数String::trim, x-&gt;x.trim();String::concat, (x,y)-&gt;x.concat(y);//Class::staticMethod，Class.staticMethod(param...)Integer::valueof, x-&gt;Integer.valueof(x);Integer::sum, (x,y)-&gt;Integer.sum(x,y) 如果有重载方法，编译器会根据上下文进行推断，判断调用哪个方法。 关于this，super1var timer = new Timer(1000, super::greet); 构造器引用123//Class::newInteger::new, x-&gt;new Integer(x);Integer[]::new, x-&gt;new Integer[x]; 变量作用域lambda表达式的组成： 一个代码块 参数 传入的参数是引用类型的话，传入的是引用的拷贝，即入参对象的引用不会改变 自由变量的值，指非参数而且不在表达式代码中定义的变量 自由变量必须是引用不会改变的，必须加final 处理lambda表达式lambda表达式的重点是代码块的延迟执行。 1234567public Interface IntConsumer{ void accept(int value);}public static void repeat(int n, IntConsumer action){ for (int i=0; i &lt; n; i++) action.accept(i);} 基本类型的函数式接口 函数式接口 参数类型 返回类型 抽象方法名 BooleanSupplier 无 boolean getAsBoolean PSupplier 无 p getAsP PConsumer p void accept objPConsumer T,p void accept PFunction p T apply PToQFunction p q applyAsQ ToPFcuntion T p applyAsP ToPBiFunction&lt;T,U&gt; T,U p applyAsP PUnaryOperator p p applyAsP PBinaryOperator p,p p applyAsP PPredicate p boolean test Comparator接口123456789101112131415// Comparator.comparing返回一个Comparator实例，内部调用Person.getName方法Arrays.sort(people, Comparator.comparing(Person::getName));// 多个比较条件Arrays.sort(people, Comparator.comparing(Person::getName) .thenComparing(Person::getFirstName));// 基本类型的比较，避免装箱与拆箱Arrays.sort(people, Comparator.comparingInt(p -&gt; p.getName().length()));// null类型适配器，避免NPE，将null标记为小于或大于正常值Arrays.sort(people, Comparator.comparing( Person::getMiddleName, Comparator.nullFirst(Comparator.&lt;String&gt;naturalOrder())); 内部类定义：定义在一个类内部的类 可以对同一个包中的其他类隐藏 内部类方法可以方位定义这个类的作用域中的数据，包括原本私有的数据 实际是编译器生成的语法糖。 内部类访问外部对象状态1234567891011121314151617181920public class TalkingClock { private int interval; private boolean beep; public TalkingClock(int interval, boolean beep){...} public void start() { var listener = new TimePrinter(); // 实例化内部类 var timer = new Timter(interval, listener); timer.start(); } public class TimePrinter implements ActionListener { public void actionPerformed(ActionEvent event) { // 访问外部对象状态 if(beep){...} } }} 特殊语法规则 显示引用外部对象 12// OuterClass.thisif(TalkingClock.this.beep) {...} 外部类显示构造内部对象 12// outerObject.new InnerClass(construction parameters)ActionListener listener = this.new TimePrinter(); 外部类之外，使用内部类 12var jabberer = new TalkingClock(1000, true);TalkingClock.TimePrinter listener = jabberer.new TimePrinter(); 内部类是否有用、必要和安全内部类是一个编译器现象，与虚拟机无关。编译器会把内部类转换为常规的类文件，用$分隔外部类名与内部类名，而虚拟机对此一无所知。 1234567891011121314151617181920212223public class innerClass.TalkingClock$TimePrinter implements java.awt.event.ActionListener { // 程序员不能使用这个字段，因为this$0是编译器在编译时生成的，存储外部类的对象引用 final innerClass.TalkingClock this$0; public innerClass.TalkingClock$TimePrinter(innerClass.TalkingClock); public void actionPerformed(java.awt.event.ActionEvent)}class Talking { private int interval; private boolean beep; public TalkingClock(int,boolean); // 编译生成，用来给内部类访问外部类的状态值的方法 // if(beep) 将转换为 if(TalkingClock.access$0(this$0)) static boolean access$0(TalkingClock); public void start();} 缺陷：会被属性程序结构的黑客调用虚拟机方法获取内部状态，由于隐私方法需要拥有包可见性，因此攻击代码要与被攻击类放在同一个包中。 私有内部类的构造器和方法虚拟机中不存在私有类，编译器会生成一个近乎最好的结果，生成的这个类有包可见性和一个私有构造器 12345678private TalkingClock$TimePrinter(TalkingClock);// 它将调用第一个构造器，TalkingClock$1类只是为了将这个构造器和其他构造器区分开// 这样不会无意中调用该方法，其包含了一个TalkingClock$1类TalkingClock$TimePrinter(TalkingClock, TalkingClock$1);// TalkingClock类start方法中的构造器调用将被转换为TalkingClock$TimePrinter(this, null); 局部内部类局部类不能有访问修饰符（private，public） 局部类的作用域被限定在声明这个局部类的块中 局部类对外界完全隐藏，除了start方法外都不能访问它。 1234567891011public void start(){ class TimePrinter implements ActionListener { public void actionPerformed(ActionEvent event) { if(beep){...} } }}var listener = new TimePrinter();var timer = new Timer(interval, listener);timer.start(); 由外部方法访问变量局部类不仅可以访问外部类的字段，还可以访问局部变量，不过局部变量必须时事实最终变量（即一旦赋值绝不改变）。 局部最终变量原因：传递给内部类的时候会对值进行复制（调用构造器，元类型复制值，对象类型复制地址），此时要保证传递时与使用时值是一致的。 12345678910111213141516171819public void start(int interval, int beep){ class TimePrinter implements ActionListener { public void actionPerformed(ActionEvent event) { // beep就是事实最终变量 if(beep){...} } }}public class TalkingClock$TimePrinter implements java.awt.event.ActionListener { final TalkingClock this$0; final boolean val$beep; // 编译器生成对应构造函数，用于保存局部变量 public TalkingClock$TimePrinter(TalkingClock, boolean); public void actionPerformed(java.awt.event.ActionEvent)} 匿名内部类（lambda实际原理）如果只想创建这个类的一个对象，甚至不需要为类指定名字，这样的类称为匿名内部类（即把类名都省略掉）。 12345678public void start(int interval, int beep){ var listener = new ActionListener() { public void actionPerformed(ActionEvent event) { if(beep){...} } }} 语法含义：创建一个类的新对象，这个类实现了SuperType（可以是接口/类），需要实现的方法在 {} 内定义 匿名类没有类名，所以不能有构造器。实际上，构造参数要传递给超类的构造器。 123new SuperType(construction parameters) { inner class methods and data} 具体的，内部类实现一个接口，就不能有任何构造参数。不过仍然要提供一组小括号。 123new InterfaceType(){ methods and data} 静态内部类有时候，使用内部类只是为了把一个类隐藏在另外一个类内部，并不需要有外围类对象的引用，为此，可以将内部类声明为static，这样就不会生成那个引用。 只有内部类可以声明为static、private，静态内部类类似于其他内部类，不过静态内部类没有生成他的外围类的对象引用。 内部类不需要访问外围类对象，就应该使用静态内部类 与常规内部类不同，静态内部类可以有静态字段和方法 在接口中声明的内部类自动是static和public 12345678910class ArrayAlg{ ... public static class Pair { ... } ...} 代理何时使用代理利用代理可以在运行时创建实现了一组给定接口的新类。 只有在编译时期无法确定需要实现哪个接口时才有必要使用代理。 代理类可以在运行时创建全新的类，这样代理类能够实现你指定的接口。 代理类包含以下方法 指定接口所需的全部方法 Object类中的全部方法，例如，toString，equals等 创建代理对象使用Proxy类的newInstance方法 一个类加载器 一个class对象数组，每个元素对应需要实现的各个接口 一个调用处理器 123456789101112131415161718192021222324// 调用器，处理代理逻辑public TraceHandler implements InvocationHandler{ private Object target; public TraceHandler(Object t) { target = t; } public Object invoke(Object proxy, Method m, Object[] args) throws Throwable { ...; return m.invoke(target, args); }}// 实例化调用器var handler = new TraceHandler(value);// 代理类构造器Object proxy = Proxy.newProxyInstance(ClassLoader.getSystemClassLoader(), new Class[] {Comparable.class}, handler); 代理类的特性 代理类时在程序运行过程中动态创建的，一旦被创建，他们就变成了常规类，与虚拟机中其他类没有什么区别。 所有代理类都扩展Proxy类，一个代理类只有一个实例字段–即调用处理器，它在Proxy超类中定义。 所有代理类都要覆盖Object类的toString、equals、hashCode方法 没有定义代理类的名字，Oracle虚拟机将生成一个以字符串$Proxy开头的类名 对于一个特点的类加载器和预设的一组接口来说，只能有一个代理类 如果使用同一个类加载器和接口数组调用两次newProxyInstance将得到同一个类的两个对象。 也可以利用Proxy.getProxyClass(null, interfaces)获取这个类 代理类总是public和final 如果代理类实现的所有接口都是public，这个代理类就不属于任何特定的包，否则所有非公共的接口都必须属于同一个包，同时代理类也属于这个包。 可以通过Proxy.isProxyClass方法检测一个特定的Class对象是否表示一个代理类 123java.lang.reflect.InvocationHandler;Object invode(Object proxy, Method method, Object[] args); 12345678910java.lang.reflect,Proxy;// 返回实现指定接口的代理类static Class&lt;?&gt; getProxyClass(ClassLoader loader, Class&lt;?&gt;... interfaces);// 构造实现指定接口的代理类实例，所有方法都调用给定处理器对象的invoke方法static Object newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler handler);// 如果cl是一个代理类，则返回truestatic boolean isProxyClass(Class&lt;?&gt; cl) 异常应该精心地编写代码来避免这些错误的发生，而不要将精力花在编写异常处理器上 I/O java中nio分为文件io和网络io，对于os这是两块不同的东西，java进行了包装 java的i/o就是对操作系统接口的封装 io中核心类是ByteBuffer，分为DirectByteBuffer和HeapByteBuffer HeapByteBuffer，受gc管理，就是个java普通数组 DirectByteBuffer，数组，实际在堆外，nio中用来进行文件的读写 文件拷贝 传统IO NIO","link":"/2021/08/05/java-core/"}],"tags":[{"name":"java","slug":"java","link":"/tags/java/"}],"categories":[{"name":"java","slug":"java","link":"/categories/java/"}]}